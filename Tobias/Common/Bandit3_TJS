# Promptoptimierung GUI und DREI TEILE:
# XXX.gui.py (Tkinter) und XXX.app.py und XXX.logic.py (xxx_logic.py mit class Environment (World)-> class Agent->class Policy, maybe multiple policies)


Bitte erstelle mir aus folgenden Anweisungen einen Prompt, den Du gut verstehst:
# GUI erweitert
Nutze Code aus Datei "Bandit2_TJS-py"!
Teile die GUI in oberen und unteren Bereich auf.
Im oberen Bereich soll eine Überschrift "Viel MANUELLEN Erfolg Dir!!!" angezeigt werden.
Im unteren Bereich soll eine Überschrift "Dies wird vom Agenten gesteuert!!!" angezeigt werden.
Sowohl der obere als auch der untere Bereich sollen drei Banditen (Buttons) bereitstellen.
Bennene diese drei Buttons als Bandit mit laufender Nummer.
Jedem Banditen wird beim Programmstart eine Auszahlungswahrscheinlichkeit fest zugewiesen.
Bandit 1: 20%. Bandit 2: 40%. Bandit 3: 80%.
Nur mit dieser Wahrscheinlichkeit soll bei jedem Klick eines Banditen berechnet werden, ob überhaupt etwas ausgezahlt wird.
Die mögliche Auszahlung soll also Bernoulli-Logik entsprechen.
Jeder Bandit hat zwei Labels daneben/unterhalb:
"Anzahl Klicks: N" — zählt, wie oft der Bandit angeklickt wurde.
"Ausgabewert: X" — zeigt den zuletzt erzeugten Ausgabewert und die Summe der bisherigen Auszahlungen.
Klick-Verhalten: Wenn ein Bandit angeklickt wird, wird die Klick-Anzahl erhöht und ein neuer Ausgabewert generiert:
Erstelle je Bandit zwei Labels, die Anzahl Klicks und Ausgabewert anzeigen.
Im oberen Bereich soll der Nutzer die drei Banditen anklicken können und damit aktivieren.
Im untereen Bereich soll der Agent die drei Banditen automatisch anklicken, um die Auszahlungen zu maximieren.
Nach jedem Klick die beiden Labels des jeweiligen Banditen aktualisieren.
UI muss responsiv sein und wiederholte Klicks erlauben.
Zeige die Wahrscheinlichkeit p als zusätzliches kleines Label pro Bandit.
Anzehl der Iterationen: 100.

1) Erzeuge einen lauffähigen Code und ändere die bereits fertige Datei "TJS_bandit_13.py" im Ordner Common von Tobias:
   - Drei einarmige Banditen (Slots).
   - Starten kostet 1 Coin pro Spiel.
   - Jeder Automat gibt eine zufällige Anzahl Coins zurück; die erwartete Auszahlung steigt mit der Anzahl Coins, die bereits im Automaten sind.
   - Initialisiere die Automaten mit drei unterschiedlichen Startmengen (20, 40, 80).
   - Berechne die Wahrscheinlichkeit für die Ausgabe von Coins gemäß der Formel: bereits eingeführte Coins/100
   - GUI: 3 Buttons (1 button je Automat). Button drücken wirft 1 Coin ein und startet das Spiel.
   - Über den Buttons steht der Text: "Viel Erfolg beim Zocken!"
   - Für jeden Button zeige: Anzahl Versuche (Clicks) und Anzahl zurückgegebener Coins (gesamt).



# RL-Modell erstellen
Erweitere den aktuellen Stand des Projekts und der GUI (für User und Agent!) in ein Reinforcement Projekt. Berücksichtigee dafür folgende Requirements:
- Ziel: der Agent soll herausfinden von welchem Automaten die meisten Coins ausgeworfen werden.
- Erstelle einen lauffähigen Code und ändere die fertigen Dateien: TJS_bandit_gui.py; TJS_bandit_app.py; TJS_bandit_logic.py.
- Inhalt von TJS_bandit_app.py soll entry point für die Initialisierung der anderen Klassen sein
- Inhalt von TJS_bandit_gui.py:
   - Klasse GUI
   - Tkinter GUI basierend auf der bestehenden GUI
   - erweitere die GUI um die Buttons: Agent EINMAL; Agent ALLE Iterationen; RESET STATE
   - füge Plots (matplotlib) hinzu: cumulative reward; Legende für Policy; unterschiedliche Farbe für unterschiedliche policies; live plot
- Inhalt von TJS_bandit_logic.py:
   - Klasse "Bandit":
      - einarmiger Bandit gemäß des bestehenden codes
      - eine Instanz pro Bandit
   - Klasse "Environment":
      - erstellt die Welt, bestehend aus den drei einarmigen Banditen
   - Klasse "Agent":
      - Agent, der die Spielautomaten nutzt
      - action: ausführen eines Automaten
      - reward: vom Automaten ausgeworfene Coins
   - Klasse "policy":
      - bestimmt die policy für das Training des Agenten

Anzahl Iterationen = 100.
- Agent Loops (n) = Anzahl Iterationen
- Agent Memory (0=all) = 0
- Epsilon = 0.9; Decay = 0.01
- Policy: Epsilon-Greedy; Thompson Sampling
- Current state: bandit; pulls; success; success_rate

Bitte nutze live plot!

Bei Aktivierung der Buttons im unteren Bereich der GUI soll AGENT agieren!!!

Aktuelle Darstellung des LIVE PLOTS bitte aktivieren und nutzen!!!

Generiere bitte ausführbaren Code!!!


###################################### AI-PROMPT_1

Bitte nutze folgenden Code als Basis für GUI-Erweiterung:
import tkinter as tk
import random

class BanditFrame(tk.Frame):
    def __init__(self, master, index, p, *args, **kwargs):
        super().__init__(master, *args, **kwargs)
        self.index = index
        self.p = p
        self.clicks = 0
        self.last = "-"
        self.total = 0

        self.btn = tk.Button(self, text=f"Bandit {index}", width=16, command=self.on_click)
        self.btn.grid(row=0, column=0, columnspan=2, pady=(0,6))

        self.p_label = tk.Label(self, text=f"p = {int(self.p*100)}%", font=("TkDefaultFont", 9))
        self.p_label.grid(row=1, column=0, columnspan=2)

        self.clicks_label = tk.Label(self, text=f"Anzahl Klicks: {self.clicks}")
        self.clicks_label.grid(row=2, column=0, sticky="w", padx=(4,8))

        self.value_label = tk.Label(self, text=f"Ausgabewert: {self.last} (Summe: {self.total})")
        self.value_label.grid(row=2, column=1, sticky="e", padx=(8,4))

    def on_click(self):
        self.clicks += 1
        # Bernoulli: Auszahlung nur bei Erfolg, sonst 0
        if random.random() < self.p:
            payout = random.randint(50, 100)
        else:
            payout = 0
        self.last = payout
        self.total += payout
        self.update_labels()

    def update_labels(self):
        self.clicks_label.config(text=f"Anzahl Klicks: {self.clicks}")
        self.value_label.config(text=f"Ausgabewert: {self.last} (Summe: {self.total})")

def main():
    root = tk.Tk()
    root.title("3-Banditen")
    root.minsize(640, 240)

    container = tk.Frame(root, padx=12, pady=12)
    container.pack(fill="both", expand=True)

    header = tk.Label(container, text="Viel Erfolg Dir!!!", font=("TkDefaultFont", 16, "bold"))
    header.grid(row=0, column=0, columnspan=3, pady=(0,12))

    probabilities = [0.20, 0.40, 0.80]
    bandit_frames = []
    for i, p in enumerate(probabilities, start=1):
        bf = BanditFrame(container, i, p, bd=1, relief="groove", padx=8, pady=6)
        bf.grid(row=1, column=i-1, padx=8, sticky="nsew")
        bandit_frames.append(bf)

    for c in range(3):
        container.grid_columnconfigure(c, weight=1)

    root.mainloop()

if __name__ == "__main__":
    main()

Erzeuge ein vollständiges, lauffähiges Python‑3‑Projekt (sofort ausführbare Dateien) nach folgenden Vorgaben.

Ziel: GUI + RL‑Version von 3‑Armigen Banditen mit Bernoulli‑Auszahlungen, plus Tests und Startanweisung.

Allgemein / Anforderungen
- Sprache: Python 3. Nur Standardbibliothek für Kern; matplotlib optional für Live‑Plot (falls verfügbar, nutze, sonst graceful fallback).
- Trenne Logik und GUI: keine Business‑Logik in Tkinter‑Code.
- Responsives GUI: keine Blockierung des Hauptthreads (Threading/after verwenden).
- Liefere sofort lauffähige Dateien: TJS_bandit_13.py, TJS_bandit_logic.py, TJS_bandit_gui.py, TJS_bandit_app.py sowie pytest‑Teststubs.

TJS_bandit_13.py (Standalone GUI)
- Tkinter App, Header zentriert: "Viel Erfolg beim Zocken!".
- Drei Bandits initialisiert mit start_coins = [20,40,80].
- Player‑Credit initial z.B. 100; jeder Pull kostet 1 Coin.
- Für jeden Bandit p = clamp(start_coins / 100, 0, 1).
- Pull: Bernoulli(p) → bei Erfolg payout = random.randint(1, start_coins); sonst payout = 0.
- UI: je Bandit Button (Bandit 1..3), kleines Label p, "Anzahl Versuche: N", "Zurückgegebene Coins: S", Player‑Coins Label.
- Nach jedem Klick Labels sofort aktualisieren; Buttons deaktivieren bei 0 Player‑Coins.

TJS_bandit_logic.py (separat)
- Klasse Bandit(start_coins): p‑Property, pull() → payout, aktualisiert pulls, successes, total_reward.
- Klasse Environment(starts=(20,40,80)): list der Bandits, step(action) → reward.
- Klasse Policy (Interface) und Implementierungen:
  - EpsilonGreedyPolicy(epsilon=0.9, decay=0.01)
  - ThompsonSamplingPolicy()
- Klasse Agent(env, policy): step() wählt Aktion, führt env.step, aktualisiert estimates/counts/rewards.
- Hilfsfunktion run_iterations(env, agent, n=100).

TJS_bandit_gui.py (RL GUI)
- Klasse GUI: erweitert die Bandit‑GUI, zeigt oben manuellen Bereich ("Viel MANUELLEN Erfolg Dir!!!") mit 3 Buttons und unten Agentenbereich ("Dies wird vom Agenten gesteuert!!!") mit 3 Bandits (Status).
- Zusätzliche Controls: Radiobutton Policy (Epsilon/Thompson), Buttons: "Agent EINMAL", "Agent ALLE Iterationen", "RESET STATE".
- Live Plot (matplotlib wenn vorhanden): cumulative reward vs iteration, unterschiedliche Farben/Legende je Policy, live update während Agent‑Runs.
- Agent ALLE Iterationen führt n=100 Iterationen in Hintergrundthread aus; GUI bleibt responsiv.

TJS_bandit_app.py
- Entry point: initialisiert Environment/GUI und startet Tk mainloop.

Tests (pytest stubs)
- tests/test_bandit.py:
  - test_p_calculation(): assert p == expected.
  - test_pull_deterministic(): seed RNG, pull(), verify payout type and stats update.
  - test_agent_step_updates_estimates(): smoke test for Agent.step.

Dokumentation / Deliverables
- Kurze Zusammenfassung (2–3 Sätze), nummerierte Implementierungsschritte mit Priorität (hoch/mittel/niedrig) und Stunden‑Schätzung.
- Minimale Projektstruktur + kurze Code‑Stubs (Dateiname + 1–2 Zeilen Beschreibung).
- PowerShell Beispielbefehl zum Starten:
  - python "c:\GIT_TJS\TJS_bandit_13.py"
  - python "c:\GIT_TJS\TJS_bandit_app.py" (falls matplotlib installiert)

Agent‑Parameter (festlegen)
- iterations = 100
- memory = 0 (all)
- epsilon_start = 0.9, decay = 0.01
- Policies: Epsilon‑Greedy, Thompson Sampling
- Track per bandit: pulls, successes, success_rate, total_reward, estimated_mean

Implementationshinweise
- Verwende random.seed optional in Tests for Determinismus.
- In GUI für live Plot: aktualisiere matplotlib via canvas.draw_idle() aus root.after oder Background‑Thread + root.after.
- Stelle sicher, dass TJS_bandit_logic.py vollständig testbar ohne GUI ist.

Maximal 5 Rückfragen (falls nötig)
1) Soll start_coins der Bandits nach Auszahlungen verändert werden oder konstant bleiben?
2) Welches Startguthaben für Player bevorzugen (Standard 100 ok)?
3) Soll payout die Bandit‑start_coins erhöhen/vermindern oder nur total_reward zählen?
4) Matplotlib erlauben? (Ja/Nein)
5) Gewünschtes Persistenzformat für Ergebnisse (CSV/JSON/keine)?

Erzeuge jetzt das komplette Projekt entsprechend diesem Prompt (Dateien lauffähig).





